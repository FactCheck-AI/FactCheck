In what year was Plankalkul designed? In what year was that design published?

Plankalkul was design in 1945 and the design was published in 1972

What two common data structures were include in Plankalkul?

Two common data structures were include in Plankalkul are aray and records

How were the pseudecodes of the early 1950s implemented?

The pseudecodes of the early 1950s implemented was through machine code

Why was the slowness of interpretation of programs acceptable in early 1950s?

The slowness of interpretation of programs acceptable in early 1950s, because lack of floating point hardware.

In what year was the Fortan design project begun?

The fortan design project begun in may 1954.

What was the primary application area of computers at the time Fortran was designed?

the primary application area of computers at the time Fortran was designed is mathematics.

What was the most significant feature added to fortran I to get fortran II?

the most significant feature added to fortran I to get fortran II is independent-compilation capability.

Which version of fortran was the first to have any sort of dynamic variables?

The version of fortran was the first to have any sort of dynamic variables is fortran 90.

Which version of fortran was the first to have character string handling?

The version of fortran was the first to have character string handling is fortran 77.

Where was LISP developed? By whom?

LISP was developed at MIT by Jhon McCarthy.

What dialect of LISP is used for the introductory programming course at some universities?

Dialect of LISP is used for the introductory programming course at some universities is scheme.

What two professional organizations together designed LAGOL 60?

Professional organizations together designed LAGOL 60 ACM and GAMM

In what version of ALGOL did block structure appear?

Version of ALGOL did block structure appear is ALGOL 60.

What language was designed to describe the syntax of ALGOL 60?

Language was designed to describe the syntax of ALGOL 60 is BNF.

On what language was COBOL based?

COBOL based on flow-matic language.

In what year did the COBOL design process begin?

The COBOL design process begin in 1959.

What user group was the target of the first version of BASIC?

User group that was the target of the first version of BASIC is nonscience students.

What features of SIMULA 67 are now important parts of some object-oriented languages?

Features of SIMULA 67 are now important parts of some object-oriented languages is data abstraction.

What innovation of data structuring was introduces in ALGOL 68 but is often credited to pascal?

Innovation of data structuring was introduces in ALGOL 68 but is often credited to pascal is user-defined data types.

What design criterion was used extensively in ALGOL 68?

Design criterion was used extensively in ALGOL 68 is orthogonality.

What language introduced the case statement?

Language that introduced the case statement is algol-W.

What are the two kinds of statements that populate a prolog database?

Two kinds of statements that populate a prolog database are facts and rules.

What is the primary application area for which Ada was designed?

The primary application area for which Ada was designed is embedded systems.

5. Which of the three original goals of the ALGOL design committee, in your opinion, was most difficult to achieve at that time?

I agree with the text that something entirely new to the computing business would be the most difficult to achieve (Sebesta, 2002. p 56). The first requirement, “as close as possible to standard mathematical notation, and …should be readable with little further explanation” appear to be the direction programming languages were heading, especially with scientists and mathematicians leading the way and scientific programming was a primary focus of computing. Without implementing the last requirement, “…the new language must be mechanically translatable into machine language,” it would be impossible for the system IO to determine what instructions were being requested since computers can’t guess in that capacity. Developing a language that mimicked pseudocode or symbolic description for the purpose of publication was definitely be the most difficult challenge of the three at that time.

7. LISP began as a pure functional language but gradually acquired more and more imperative features. Why?

John McCarthy’s original interest in developing LISP was to meet the demand for artificial intelligence as a functional programming language, but there soon emerged different dialects, cleaners, more modern, and more imperative, that began to deviate from the functional form into Scheme. COMMON LISP combined the different forms into a single form that was more imperative, including assignment and iteration.

8. Describe in detail the three most important reasons, in your opinion, why ALGOL 60 did not become a very widely used language.

Excessive flexibility hurt ALGOL60 since languages that are difficult to learn were not as well received as languages with a more rigid structure. Allowing a large number of possibilities also introduces an element of inefficiency since the methods to complete a task would differ between programmers. Second, Sebesta (2002, p. 60) notes that its association with BNF alienated the language as strange and complicated. If programmers are not excited about using a language, they will always find a different one. The third and perhaps the most important reason that ALGOL60 was not very widely used was because of a lack of support from IBM, who was at the time the preeminent company for using computer languages. Without some help from a large corporation, ALGOL60 did not have much of a chance, much like COBOL without the DoD.

9. Why, in your opinion, did COBOL allow long identifiers when FORTRAN and ALGOL did not?

COBOL required that managers without a background in programming should be able to read programs and English should be used as much as possible. This caused identifiers to be longer, making the language more English-like. Sebesta (2002, p. 57) states that “[ALGOL] identifiers were allowed to have any length, as opposed to FORTRAN’s restriction to six or fewer….” FORTRAN was also a much older language that was built during a time of very little memory and a focus on syntax “as close as possible to standard mathematical notation” leaving little room for long identifiers.

13. Describe, in your own words, the concept of orthogonality in programming language design.

It appears that orthogonality means the simplicity of programming constructs, or a minimal number of control and data structures in a language. Each additional construct increases the complexity, removing orthogonality.

15. What are the arguments both for and against the idea of a typeless language?

Arguments for are obvious flexibility and ease of use. Without having to define a data type the programmer is free to develop code that is generated quickly and without much thought. Learning the language is much simpler because one doesn’t have to determine size or how the compiler will interpret the type later on, only what information must be included.

Arguments against include data insecurity, such as the assignment of a character type ‘A’ that could in fact be “defined” as a HEX value by the programmer. The compiler would also have trouble interpreting floating point values compared to integers. The resulting arithmetic would also cause serious problems; like adding 5 + “happy” and how they are interpreted different than perhaps the programmer intended.

18. Do you think language design by committee is a good idea? (Support your opinion)

Language design by committee definitely has its advantages, with varying points of view from different domains, different programming backgrounds, and even different language backgrounds all contributing for the better of the language like ALGOL 58. Knowledge of Plankalkul enhanced ALGOL 58 because members from Europe were familiar with the language. Improvements like variable length identifiers and array dimensions were improved upon previous languages. Even though many arguments and conflicts arise, like whether to use a comma (European) or a period (American) for a decimal point took place, it is beneficial to have options. I think history would show that the best use of committees would be after a language has been invented and accepted. At this point a better evaluation is possible and committee members would be better conditioned to make improvements than initial discoveries.

22. Explain two reasons why pure interpretation is an acceptable implementation method for several recent scripting languages.

First all run-time error messages can refer to source-level units. For example, if an array index is found to be out of range, the error message can easily indicate the source line and the name of the array. On the other hand, this method has the serious disadvantage that

execution is 10 to 100 times slower than in compiled systems.

Second Pure interpretation systems perform no translation; rather, programs are interpreted in their original form by a software interpreter. Pure interpretation is usually used for smaller systems in which execution efficiency is not critical, such as scripts embedded in HTML documents, written in languages such as JavaScript.